<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>
<body>
Code to search indices.

<h2>Table Of Contents</h2>
<p>
    <ol>
        <li><a href="#search">Search Basics</a></li>
        <li><a href="#query">The Query Classes</a></li>
        <li><a href="#scoring">Changing the Scoring</a></li>
    </ol>
</p>
<a name="search"></a>
<h2>Search</h2>
<p>
Search over indices.

Applications usually call {@link
org.apache.lucene.search.IndexSearcher#search(Query,int)} or {@link
org.apache.lucene.search.IndexSearcher#search(Query,Filter,int)}.

    <!-- FILL IN MORE HERE -->   
    <!-- TODO: this page over-links the same things too many times -->
</p>
<a name="query"></a>
<h2>Query Classes</h2>
<h4>
    {@link org.apache.lucene.search.TermQuery TermQuery}
</h4>

<p>Of the various implementations of
    {@link org.apache.lucene.search.Query Query}, the
    {@link org.apache.lucene.search.TermQuery TermQuery}
    is the easiest to understand and the most often used in applications. A
    {@link org.apache.lucene.search.TermQuery TermQuery} matches all the documents that contain the
    specified
    {@link org.apache.lucene.index.Term Term},
    which is a word that occurs in a certain
    {@link org.apache.lucene.document.Field Field}.
    Thus, a {@link org.apache.lucene.search.TermQuery TermQuery} identifies and scores all
    {@link org.apache.lucene.document.Document Document}s that have a 
        {@link org.apache.lucene.document.Field Field} with the specified string in it.
    Constructing a {@link org.apache.lucene.search.TermQuery TermQuery}
    is as simple as:
    <pre>
        TermQuery tq = new TermQuery(new Term("fieldName", "term"));
    </pre>In this example, the {@link org.apache.lucene.search.Query Query} identifies all 
        {@link org.apache.lucene.document.Document Document}s that have the 
        {@link org.apache.lucene.document.Field Field} named <tt>"fieldName"</tt>
    containing the word <tt>"term"</tt>.
</p>
<h4>
    {@link org.apache.lucene.search.BooleanQuery BooleanQuery}
</h4>

<p>Things start to get interesting when one combines multiple
    {@link org.apache.lucene.search.TermQuery TermQuery} instances into a 
        {@link org.apache.lucene.search.BooleanQuery BooleanQuery}.
    A {@link org.apache.lucene.search.BooleanQuery BooleanQuery} contains multiple
    {@link org.apache.lucene.search.BooleanClause BooleanClause}s,
    where each clause contains a sub-query ({@link org.apache.lucene.search.Query Query}
    instance) and an operator (from 
        {@link org.apache.lucene.search.BooleanClause.Occur BooleanClause.Occur})
    describing how that sub-query is combined with the other clauses:
    <ol>

        <li><p>{@link org.apache.lucene.search.BooleanClause.Occur#SHOULD SHOULD} &mdash; Use this operator when a clause can occur in the result set, but is not required.
            If a query is made up of all SHOULD clauses, then every document in the result
            set matches at least one of these clauses.</p></li>

        <li><p>{@link org.apache.lucene.search.BooleanClause.Occur#MUST MUST} &mdash; Use this operator when a clause is required to occur in the result set. Every
            document in the result set will match
            all such clauses.</p></li>

        <li><p>{@link org.apache.lucene.search.BooleanClause.Occur#MUST_NOT MUST NOT} &mdash; Use this operator when a
            clause must not occur in the result set. No
            document in the result set will match
            any such clauses.</p></li>
    </ol>
    Boolean queries are constructed by adding two or more
    {@link org.apache.lucene.search.BooleanClause BooleanClause}
    instances. If too many clauses are added, a {@link org.apache.lucene.search.BooleanQuery.TooManyClauses TooManyClauses}
    exception will be thrown during searching. This most often occurs
    when a {@link org.apache.lucene.search.Query Query}
    is rewritten into a {@link org.apache.lucene.search.BooleanQuery BooleanQuery} with many
    {@link org.apache.lucene.search.TermQuery TermQuery} clauses,
    for example by {@link org.apache.lucene.search.WildcardQuery WildcardQuery}.
    The default setting for the maximum number
    of clauses 1024, but this can be changed via the
    static method {@link org.apache.lucene.search.BooleanQuery#setMaxClauseCount(int)}.
</p>

<h4>Phrases</h4>

<p>Another common search is to find documents containing certain phrases. This
    is handled three different ways:
    <ol>
        <li>
            <p>{@link org.apache.lucene.search.PhraseQuery PhraseQuery}
                &mdash; Matches a sequence of
                {@link org.apache.lucene.index.Term Term}s.
                {@link org.apache.lucene.search.PhraseQuery PhraseQuery} uses a slop factor to determine
                how many positions may occur between any two terms in the phrase and still be considered a match.</p>
        </li>
        <li>
            <p>{@link org.apache.lucene.search.MultiPhraseQuery MultiPhraseQuery}
                &mdash; A more general form of PhraseQuery that accepts multiple Terms
                for a position in the phrase. For example, this can be used to perform phrase queries that also
                incorporate synonyms.
        </li>
        <li>
            <p>{@link org.apache.lucene.search.spans.SpanNearQuery SpanNearQuery}
                &mdash; Matches a sequence of other
                {@link org.apache.lucene.search.spans.SpanQuery SpanQuery}
                instances. {@link org.apache.lucene.search.spans.SpanNearQuery SpanNearQuery} allows for
                much more
                complicated phrase queries since it is constructed from other 
                    {@link org.apache.lucene.search.spans.SpanQuery SpanQuery}
                instances, instead of only {@link org.apache.lucene.search.TermQuery TermQuery}
                instances.</p>
        </li>
    </ol>
</p>

<h4>
    {@link org.apache.lucene.search.TermRangeQuery TermRangeQuery}
</h4>

<p>The
    {@link org.apache.lucene.search.TermRangeQuery TermRangeQuery}
    matches all documents that occur in the
    exclusive range of a lower
    {@link org.apache.lucene.index.Term Term}
    and an upper
    {@link org.apache.lucene.index.Term Term}
    according to {@link org.apache.lucene.index.TermsEnum#getComparator TermsEnum.getComparator()}. It is not intended
    for numerical ranges, use {@link org.apache.lucene.search.NumericRangeQuery NumericRangeQuery} instead.

    For example, one could find all documents
    that have terms beginning with the letters <tt>a</tt> through <tt>c</tt>. This type of 
        {@link org.apache.lucene.search.Query} is frequently used to
    find
    documents that occur in a specific date range.
</p>

<h4>
    {@link org.apache.lucene.search.NumericRangeQuery NumericRangeQuery}
</h4>

<p>The
    {@link org.apache.lucene.search.NumericRangeQuery NumericRangeQuery}
    matches all documents that occur in a numeric range.
    For NumericRangeQuery to work, you must index the values
    using a one of the numeric fields ({@link org.apache.lucene.document.IntField IntField},
    {@link org.apache.lucene.document.LongField LongField}, {@link org.apache.lucene.document.FloatField FloatField},
    or {@link org.apache.lucene.document.DoubleField DoubleField}).
</p>

<h4>
    {@link org.apache.lucene.search.PrefixQuery PrefixQuery},
    {@link org.apache.lucene.search.WildcardQuery WildcardQuery},
    {@link org.apache.lucene.search.RegexpQuery RegexpQuery}
</h4>

<p>While the
    {@link org.apache.lucene.search.PrefixQuery PrefixQuery}
    has a different implementation, it is essentially a special case of the
    {@link org.apache.lucene.search.WildcardQuery WildcardQuery}.
    The {@link org.apache.lucene.search.PrefixQuery PrefixQuery} allows an application
    to identify all documents with terms that begin with a certain string. The 
        {@link org.apache.lucene.search.WildcardQuery WildcardQuery} generalizes this by allowing
    for the use of <tt>*</tt> (matches 0 or more characters) and <tt>?</tt> (matches exactly one character) wildcards.
    Note that the {@link org.apache.lucene.search.WildcardQuery WildcardQuery} can be quite slow. Also
    note that
    {@link org.apache.lucene.search.WildcardQuery WildcardQuery} should
    not start with <tt>*</tt> and <tt>?</tt>, as these are extremely slow. 
    Some QueryParsers may not allow this by default, but provide a <code>setAllowLeadingWildcard</code> method
    to remove protection.
    The {@link org.apache.lucene.search.RegexpQuery RegexpQuery} is even more general than WildcardQuery,
    allowing an application to identify all documents with terms that match a regular expression pattern.
</p>
<h4>
    {@link org.apache.lucene.search.FuzzyQuery FuzzyQuery}
</h4>

<p>A
    {@link org.apache.lucene.search.FuzzyQuery FuzzyQuery}
    matches documents that contain terms similar to the specified term. Similarity is
    determined using
    <a href="http://en.wikipedia.org/wiki/Levenshtein">Levenshtein (edit) distance</a>.
    This type of query can be useful when accounting for spelling variations in the collection.
</p>
<a name="changingSimilarity"></a>
<h2>Changing Similarity</h2>

See the {@link org.apache.lucene.search.similarities} package documentation for information
on the available scoring models and extending or changing Similarity.

<a name="scoring"></a>
<h2>Changing Scoring &mdash; Expert Level</h2>

<p>Changing scoring is an expert level task, so tread carefully and be prepared to share your code if
    you want help.
</p>

<p>With the warning out of the way, it is possible to change a lot more than just the Similarity
    when it comes to scoring in Lucene. Lucene's scoring is a complex mechanism that is grounded by
    <span >three main classes</span>:
    <ol>
        <li>
            {@link org.apache.lucene.search.Query Query} &mdash; The abstract object representation of the
            user's information need.</li>
        <li>
            {@link org.apache.lucene.search.Weight Weight} &mdash; The internal interface representation of
            the user's Query, so that Query objects may be reused.</li>
        <li>
            {@link org.apache.lucene.search.Scorer Scorer} &mdash; An abstract class containing common
            functionality for scoring. Provides both scoring and explanation capabilities.</li>
    </ol>
    Details on each of these classes, and their children, can be found in the subsections below.
</p>
<h4>The Query Class</h4>
    <p>In some sense, the
        {@link org.apache.lucene.search.Query Query}
        class is where it all begins. Without a Query, there would be
        nothing to score. Furthermore, the Query class is the catalyst for the other scoring classes as it
        is often responsible
        for creating them or coordinating the functionality between them. The
        {@link org.apache.lucene.search.Query Query} class has several methods that are important for
        derived classes:
        <ol>
            <li>{@link org.apache.lucene.search.Query#createWeight(IndexSearcher) createWeight(IndexSearcher searcher} &mdash; A
                {@link org.apache.lucene.search.Weight Weight} is the internal representation of the
                Query, so each Query implementation must
                provide an implementation of Weight. See the subsection on <a
                    href="#The Weight Interface">The Weight Interface</a> below for details on implementing the Weight
                interface.</li>
            <li>{@link org.apache.lucene.search.Query#rewrite(IndexReader) rewrite(IndexReader reader} &mdash; Rewrites queries into primitive queries. Primitive queries are:
                {@link org.apache.lucene.search.TermQuery TermQuery},
                {@link org.apache.lucene.search.BooleanQuery BooleanQuery}, <span
                    >and other queries that implement {@link org.apache.lucene.search.Query#createWeight(IndexSearcher) createWeight(IndexSearcher searcher)}</span></li>
        </ol>
    </p>
<h4>The Weight Interface</h4>
    <p>The
        {@link org.apache.lucene.search.Weight Weight}
        interface provides an internal representation of the Query so that it can be reused. Any
        {@link org.apache.lucene.search.IndexSearcher IndexSearcher}
        dependent state should be stored in the Weight implementation,
        not in the Query class. The interface defines five methods that must be implemented:
        <ol>
            <li>
                {@link org.apache.lucene.search.Weight#getQuery getQuery()} &mdash; Pointer to the
                Query that this Weight represents.</li>
            <li>
                {@link org.apache.lucene.search.Weight#getValueForNormalization() getValueForNormalization()} &mdash; 
                A weight can return a floating point value to indicate its magnitude for query normalization. Typically
                a weight such as TermWeight that scores via a {@link org.apache.lucene.search.similarities.Similarity Similarity} 
                will just defer to the Similarity's implementation: 
                {@link org.apache.lucene.search.similarities.Similarity.SimWeight#getValueForNormalization SimWeight#getValueForNormalization()}.
                For example, with {@link org.apache.lucene.search.similarities.TFIDFSimilarity Lucene's classic vector-space formula}, this
                is implemented as the sum of squared weights: <code>(idf * boost)<sup>2</sup></code></li>
            <li>
                {@link org.apache.lucene.search.Weight#normalize(float,float) normalize(float norm, float topLevelBoost)} &mdash; 
                Performs query normalization: 
                <ul>
                <li><code>topLevelBoost</code>: A query-boost factor from any wrapping queries that should be multiplied into every
                document's score. For example, a TermQuery that is wrapped within a BooleanQuery with a boost of <code>5</code> would
                receive this value at this time. This allows the TermQuery (the leaf node in this case) to compute this up-front
                a single time (e.g. by multiplying into the IDF), rather than for every document.</li> 
                <li><code>norm</code>: Passes in a a normalization factor which may
                allow for comparing scores between queries.</li>
                </ul>
                Typically a weight such as TermWeight
                that scores via a {@link org.apache.lucene.search.similarities.Similarity Similarity} will just defer to the Similarity's implementation:
                {@link org.apache.lucene.search.similarities.Similarity.SimWeight#normalize SimWeight#normalize(float,float)}.</li>
            <li>
                {@link org.apache.lucene.search.Weight#scorer(org.apache.lucene.index.AtomicReaderContext, boolean, boolean, org.apache.lucene.util.Bits)
                  scorer(AtomicReaderContext context, boolean scoresDocsInOrder, boolean topScorer, Bits acceptDocs)} &mdash;
                Construct a new {@link org.apache.lucene.search.Scorer Scorer} for this Weight. See <a href="#The Scorer Class">The Scorer Class</a>
                below for help defining a Scorer. As the name implies, the Scorer is responsible for doing the actual scoring of documents 
                given the Query.
            </li>
            <li>
                {@link org.apache.lucene.search.Weight#explain(org.apache.lucene.index.AtomicReaderContext, int) 
                  explain(AtomicReaderContext context, int doc)} &mdash; Provide a means for explaining why a given document was
                scored the way it was.
                Typically a weight such as TermWeight
                that scores via a {@link org.apache.lucene.search.similarities.Similarity Similarity} will make use of the Similarity's implementations:
                {@link org.apache.lucene.search.similarities.Similarity.ExactSimScorer#explain(int, Explanation) ExactSimScorer#explain(int doc, Explanation freq)},
                and {@link org.apache.lucene.search.similarities.Similarity.SloppySimScorer#explain(int, Explanation) SloppySimScorer#explain(int doc, Explanation freq)}
                </li>
             </li>
        </ol>
    </p>
<h4>The Scorer Class</h4>
    <p>The
        {@link org.apache.lucene.search.Scorer Scorer}
        abstract class provides common scoring functionality for all Scorer implementations and
        is the heart of the Lucene scoring process. The Scorer defines the following abstract (some of them are not
        yet abstract, but will be in future versions and should be considered as such now) methods which
        must be implemented (some of them inherited from {@link org.apache.lucene.search.DocIdSetIterator DocIdSetIterator}):
        <ol>
            <li>
                {@link org.apache.lucene.search.Scorer#nextDoc nextDoc()} &mdash; Advances to the next
                document that matches this Query, returning true if and only if there is another document that matches.</li>
            <li>
                {@link org.apache.lucene.search.Scorer#docID docID()} &mdash; Returns the id of the
                {@link org.apache.lucene.document.Document Document} that contains the match.
            </li>
            <li>
                {@link org.apache.lucene.search.Scorer#score score()} &mdash; Return the score of the
                current document. This value can be determined in any appropriate way for an application. For instance, the
                {@link org.apache.lucene.search.TermScorer TermScorer} simply defers to the configured Similarity:
                {@link org.apache.lucene.search.similarities.Similarity.ExactSimScorer#score(int, int) ExactSimScorer.score(int doc, int freq)}.
            </li>
            <li>
                {@link org.apache.lucene.search.Scorer#freq freq()} &mdash; Returns the number of matches
                for the current document. This value can be determined in any appropriate way for an application. For instance, the
                {@link org.apache.lucene.search.TermScorer TermScorer} simply defers to the term frequency from the inverted index:
                {@link org.apache.lucene.index.DocsEnum#freq DocsEnum.freq()}.
            </li>
            <li>
                {@link org.apache.lucene.search.Scorer#advance advance()} &mdash; Skip ahead in
                the document matches to the document whose id is greater than
                or equal to the passed in value. In many instances, advance can be
                implemented more efficiently than simply looping through all the matching documents until
                the target document is identified.
            </li>
            <li>
                {@link org.apache.lucene.search.Scorer#getChildren getChildren()} &mdash; Returns any child subscorers
                underneath this scorer. This allows for users to navigate the scorer hierarchy and receive more fine-grained
                details on the scoring process.
            </li>
        </ol>
    </p>
<h4>Why would I want to add my own Query?</h4>

    <p>In a nutshell, you want to add your own custom Query implementation when you think that Lucene's
        aren't appropriate for the
        task that you want to do. You might be doing some cutting edge research or you need more information
        back
        out of Lucene (similar to Doug adding SpanQuery functionality).</p>

</body>
</html>
